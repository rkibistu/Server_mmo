#pragma once

#include <string>
#include <unordered_map>

#include "SceneObjects/iSceneObject.h"
#include <utils/Math.h>
#include "Mesh.h"
#include "Material.h"
#include "Shader.h"
#include <core/AABB.h>

class SceneManager;


/**
 * This represents an actual world object.
 *
 * ATTENTION: This should never allocate or deallocate resources (like models,
 * materials, shaders, etc.) and only use them!
 */
class SceneObject : public iSceneObject {
	friend class SceneManager;
	friend class Renderer;

public:
	SceneObject(unsigned int id, std::string name, ObjectMovementType movementType);
	virtual ~SceneObject();

	virtual void Start() override;
	virtual void Update(float deltaTime) override;

	void Draw() override;

	void AddMesh(Mesh* mesh);
	void AddMaterial(Material* material) { _materials.push_back(material); }
	// Set the material from index position in materials array. Set all of them if all si true.
	void SetMaterial(Material* material, unsigned int index, bool all = false);
	void SetShader(Shader* shader) { _shader = shader; }
	inline Shader* GetShader() { return _shader; }

	void SetParent(iSceneObject* parent) override;
	iSceneObject* GetParent() override { return _parent; }

	inline void SetDrawMode(int drawMode) { _drawMode = drawMode; }

	/**
	 * Add a child to the sceneobject.
	 * It does all the necessary work:
	 *	- remove child from the old parent
	 *  - set aprent pointer for the child
	 *  - add child to the new parent
	 *  - remove child from manager vector if necessary (if it was a root object)
	 *
	 * \param child The child object to add
	 */
	void AddChild(iSceneObject* child) override;

	/**
	 * Remove a child from the sceneobject.
	 * It does all the necessary work:
	 *  - set parent pointer to null
	 *  - add object to manager vector (because without a parent, the object is now a root)
	 *  - remove child from the sceneobject
	 *
	 * \param id The id of the child that should be removed
	 */
	void RemoveChild(unsigned int id) override;

	inline std::string GetName() override { return _name; }
	inline void SetName(std::string name) override { _name = name; }
	/** Position relative to the parent */
	inline rml::Vector3 GetPosition() override  { return _position; }
	/** Absolut position */
	rml::Vector3 GetWorldPosition() override;
	/** Set the position relative to the parent */
	inline void SetPosition(rml::Vector3 position) { _position = position; }
	inline rml::Vector3 GetRotation() { return _rotation; }
	inline void SetRotation(rml::Vector3 rotation) { _rotation = rotation; }
	inline rml::Vector3 GetScale() { return _scale; }
	inline void SetScale(rml::Vector3 scale) { _scale = scale; }
	inline unsigned int GetID() { return _id; }
	inline ObjectMovementType GetMovementType() override { return _movementType; }

	/** Get the object and all children and children of children and etc */
	std::vector<iSceneObject*> GetAllObjects() override;

	/** Return an updated version of AABB (scaled and moved to world coords) */
	AABB* GetAABB();
protected:
	rml::Matrix GetModelMatrix();

	virtual void SetCustomUniforms() { ; }
	virtual void CustomDraw() { ; }

	void GenerateAABB();

protected:
	/** id is autogenerated (incremental) on every creation */
	unsigned int _id;
	std::string _name;
	rml::Vector3 _position; //relative to the parent
	rml::Vector3 _rotation; //local, not relative to parent
	rml::Vector3 _scale;    //local, not relative to parent

	/**
	 * Mesh with index 0 is associated with material with index 0 (and so on).
	 */
	std::vector<Mesh*> _meshes;
	std::vector<Material*> _materials;
	/** Shader used to render the object */
	Shader* _shader = nullptr;

	iSceneObject* _parent = nullptr;
	std::unordered_map<unsigned int, iSceneObject*> _children;

	int _drawMode;

	/* Default bounds (around default mesh). Not affected by scale or position */
	AABB* _bounds = nullptr;
	/** Bound with world tranformation applied. This is used to hceck collisions */
	AABB* _worldBounds = nullptr;

	bool _debug = false;

	ObjectMovementType _movementType;
};




